// Generated by gencpp from file gps/GPCHC_data.msg
// DO NOT EDIT!


#ifndef GPS_MESSAGE_GPCHC_DATA_H
#define GPS_MESSAGE_GPCHC_DATA_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace gps
{
template <class ContainerAllocator>
struct GPCHC_data_
{
  typedef GPCHC_data_<ContainerAllocator> Type;

  GPCHC_data_()
    : GPSWeek(0)
    , GPSTime(0)
    , Heading(0.0)
    , Pitch(0.0)
    , Roll(0.0)
    , gyrox(0.0)
    , gyroy(0.0)
    , gyroz(0.0)
    , accx(0.0)
    , accy(0.0)
    , accz(0.0)
    , Lattitude(0.0)
    , Longitude(0.0)
    , Altitude(0.0)
    , Ve(0.0)
    , Vn(0.0)
    , Vu(0.0)
    , V(0.0)
    , NSV1(0)
    , NSV2(0)
    , Status(0)
    , Age(0)
    , Warming(0)  {
    }
  GPCHC_data_(const ContainerAllocator& _alloc)
    : GPSWeek(0)
    , GPSTime(0)
    , Heading(0.0)
    , Pitch(0.0)
    , Roll(0.0)
    , gyrox(0.0)
    , gyroy(0.0)
    , gyroz(0.0)
    , accx(0.0)
    , accy(0.0)
    , accz(0.0)
    , Lattitude(0.0)
    , Longitude(0.0)
    , Altitude(0.0)
    , Ve(0.0)
    , Vn(0.0)
    , Vu(0.0)
    , V(0.0)
    , NSV1(0)
    , NSV2(0)
    , Status(0)
    , Age(0)
    , Warming(0)  {
  (void)_alloc;
    }



   typedef int32_t _GPSWeek_type;
  _GPSWeek_type GPSWeek;

   typedef int32_t _GPSTime_type;
  _GPSTime_type GPSTime;

   typedef float _Heading_type;
  _Heading_type Heading;

   typedef float _Pitch_type;
  _Pitch_type Pitch;

   typedef float _Roll_type;
  _Roll_type Roll;

   typedef float _gyrox_type;
  _gyrox_type gyrox;

   typedef float _gyroy_type;
  _gyroy_type gyroy;

   typedef float _gyroz_type;
  _gyroz_type gyroz;

   typedef float _accx_type;
  _accx_type accx;

   typedef float _accy_type;
  _accy_type accy;

   typedef float _accz_type;
  _accz_type accz;

   typedef float _Lattitude_type;
  _Lattitude_type Lattitude;

   typedef float _Longitude_type;
  _Longitude_type Longitude;

   typedef float _Altitude_type;
  _Altitude_type Altitude;

   typedef float _Ve_type;
  _Ve_type Ve;

   typedef float _Vn_type;
  _Vn_type Vn;

   typedef float _Vu_type;
  _Vu_type Vu;

   typedef float _V_type;
  _V_type V;

   typedef int32_t _NSV1_type;
  _NSV1_type NSV1;

   typedef int32_t _NSV2_type;
  _NSV2_type NSV2;

   typedef int32_t _Status_type;
  _Status_type Status;

   typedef int32_t _Age_type;
  _Age_type Age;

   typedef int32_t _Warming_type;
  _Warming_type Warming;




  typedef boost::shared_ptr< ::gps::GPCHC_data_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::gps::GPCHC_data_<ContainerAllocator> const> ConstPtr;

}; // struct GPCHC_data_

typedef ::gps::GPCHC_data_<std::allocator<void> > GPCHC_data;

typedef boost::shared_ptr< ::gps::GPCHC_data > GPCHC_dataPtr;
typedef boost::shared_ptr< ::gps::GPCHC_data const> GPCHC_dataConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::gps::GPCHC_data_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::gps::GPCHC_data_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace gps

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/indigo/share/std_msgs/cmake/../msg'], 'gps': ['/home/turtlebot/gps_ws/src/gps/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::gps::GPCHC_data_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::gps::GPCHC_data_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::gps::GPCHC_data_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::gps::GPCHC_data_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gps::GPCHC_data_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::gps::GPCHC_data_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::gps::GPCHC_data_<ContainerAllocator> >
{
  static const char* value()
  {
    return "2c380b74bb8d27352fa01b8b297ff62f";
  }

  static const char* value(const ::gps::GPCHC_data_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x2c380b74bb8d2735ULL;
  static const uint64_t static_value2 = 0x2fa01b8b297ff62fULL;
};

template<class ContainerAllocator>
struct DataType< ::gps::GPCHC_data_<ContainerAllocator> >
{
  static const char* value()
  {
    return "gps/GPCHC_data";
  }

  static const char* value(const ::gps::GPCHC_data_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::gps::GPCHC_data_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32  GPSWeek\n\
int32  GPSTime\n\
float32  Heading\n\
float32  Pitch\n\
float32  Roll\n\
float32  gyrox\n\
float32  gyroy\n\
float32  gyroz\n\
float32  accx\n\
float32  accy\n\
float32  accz\n\
float32  Lattitude\n\
float32  Longitude\n\
float32  Altitude\n\
float32  Ve\n\
float32  Vn\n\
float32  Vu\n\
float32  V\n\
int32  NSV1\n\
int32  NSV2\n\
int32  Status\n\
int32  Age\n\
int32  Warming\n\
    \n\
";
  }

  static const char* value(const ::gps::GPCHC_data_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::gps::GPCHC_data_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.GPSWeek);
      stream.next(m.GPSTime);
      stream.next(m.Heading);
      stream.next(m.Pitch);
      stream.next(m.Roll);
      stream.next(m.gyrox);
      stream.next(m.gyroy);
      stream.next(m.gyroz);
      stream.next(m.accx);
      stream.next(m.accy);
      stream.next(m.accz);
      stream.next(m.Lattitude);
      stream.next(m.Longitude);
      stream.next(m.Altitude);
      stream.next(m.Ve);
      stream.next(m.Vn);
      stream.next(m.Vu);
      stream.next(m.V);
      stream.next(m.NSV1);
      stream.next(m.NSV2);
      stream.next(m.Status);
      stream.next(m.Age);
      stream.next(m.Warming);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct GPCHC_data_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::gps::GPCHC_data_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::gps::GPCHC_data_<ContainerAllocator>& v)
  {
    s << indent << "GPSWeek: ";
    Printer<int32_t>::stream(s, indent + "  ", v.GPSWeek);
    s << indent << "GPSTime: ";
    Printer<int32_t>::stream(s, indent + "  ", v.GPSTime);
    s << indent << "Heading: ";
    Printer<float>::stream(s, indent + "  ", v.Heading);
    s << indent << "Pitch: ";
    Printer<float>::stream(s, indent + "  ", v.Pitch);
    s << indent << "Roll: ";
    Printer<float>::stream(s, indent + "  ", v.Roll);
    s << indent << "gyrox: ";
    Printer<float>::stream(s, indent + "  ", v.gyrox);
    s << indent << "gyroy: ";
    Printer<float>::stream(s, indent + "  ", v.gyroy);
    s << indent << "gyroz: ";
    Printer<float>::stream(s, indent + "  ", v.gyroz);
    s << indent << "accx: ";
    Printer<float>::stream(s, indent + "  ", v.accx);
    s << indent << "accy: ";
    Printer<float>::stream(s, indent + "  ", v.accy);
    s << indent << "accz: ";
    Printer<float>::stream(s, indent + "  ", v.accz);
    s << indent << "Lattitude: ";
    Printer<float>::stream(s, indent + "  ", v.Lattitude);
    s << indent << "Longitude: ";
    Printer<float>::stream(s, indent + "  ", v.Longitude);
    s << indent << "Altitude: ";
    Printer<float>::stream(s, indent + "  ", v.Altitude);
    s << indent << "Ve: ";
    Printer<float>::stream(s, indent + "  ", v.Ve);
    s << indent << "Vn: ";
    Printer<float>::stream(s, indent + "  ", v.Vn);
    s << indent << "Vu: ";
    Printer<float>::stream(s, indent + "  ", v.Vu);
    s << indent << "V: ";
    Printer<float>::stream(s, indent + "  ", v.V);
    s << indent << "NSV1: ";
    Printer<int32_t>::stream(s, indent + "  ", v.NSV1);
    s << indent << "NSV2: ";
    Printer<int32_t>::stream(s, indent + "  ", v.NSV2);
    s << indent << "Status: ";
    Printer<int32_t>::stream(s, indent + "  ", v.Status);
    s << indent << "Age: ";
    Printer<int32_t>::stream(s, indent + "  ", v.Age);
    s << indent << "Warming: ";
    Printer<int32_t>::stream(s, indent + "  ", v.Warming);
  }
};

} // namespace message_operations
} // namespace ros

#endif // GPS_MESSAGE_GPCHC_DATA_H
